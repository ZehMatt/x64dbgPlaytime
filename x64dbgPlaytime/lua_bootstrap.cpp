#include "lua_context.hpp"
#include "lauxlib.h"
#include "pluginsdk/bridgemain.h"
#include "plugin.h"

static const char *LuaBootstrap = "local register_read = registers.read \n"
"local register_write = registers.write \n"
"local register_names = { \n"
"\t[\"rflags\"] = true,\n"
"\t[\"eflags\"] = true,\n"
"\t[\"rax\"] = true, \n"
"\t[\"eax\"] = true, \n"
"\t[\"ax\"] = true, \n"
"\t[\"ah\"] = true, \n"
"\t[\"al\"] = true,\n"
"\t[\"rbx\"] = true, \n"
"\t[\"ebx\"] = true, \n"
"\t[\"bx\"] = true, \n"
"\t[\"bh\"] = true, \n"
"\t[\"bl\"] = true, \n"
"\t[\"rcx\"] = true, \n"
"\t[\"ecx\"] = true, \n"
"\t[\"cx\"] = true, \n"
"\t[\"ch\"] = true, \n"
"\t[\"cl\"] = true, \n"
"\t[\"rdx\"] = true, \n"
"\t[\"edx\"] = true, \n"
"\t[\"dx\"] = true, \n"
"\t[\"dh\"] = true, \n"
"\t[\"dl\"] = true, \n"
"\t[\"rdi\"] = true, \n"
"\t[\"edi\"] = true, \n"
"\t[\"di\"] = true, \n"
"\t[\"dil\"] = true, \n"
"\t[\"rsi\"] = true, \n"
"\t[\"esi\"] = true, \n"
"\t[\"si\"] = true, \n"
"\t[\"sil\"] = true, \n"
"\t[\"rbp\"] = true, \n"
"\t[\"ebp\"] = true, \n"
"\t[\"bp\"] = true, \n"
"\t[\"bpl\"] = true, \n"
"\t[\"rsp\"] = true, \n"
"\t[\"esp\"] = true, \n"
"\t[\"sp\"] = true, \n"
"\t[\"spl\"] = true, \n"
"\t[\"rip\"] = true, \n"
"\t[\"eip\"] = true, \n"
"\t[\"r8\"] = true, \n"
"\t[\"r8d\"] = true, \n"
"\t[\"r8w\"] = true, \n"
"\t[\"r8b\"] = true, \n"
"} \n"
"local function is_register(k) \n"
"\treturn register_names[string.lower(k)] == true \n"
"end \n"
"setmetatable(_G, { \n"
"\t__index = function(t, k) \n"
"\t\tif is_register(k) then \n"
"\t\t\treturn register_read(k) \n"
"\t\tend \n"
"\t\treturn rawget(t, k) \n"
"\tend, \n"
"\t__newindex = function(t, k, v) \n"
"\t\tif is_register(k) then \n"
"\t\t\treturn register_write(k, v) \n"
"\t\tend \n"
"\t\treturn rawset(t, k, v) \n"
"\tend, \n"
"}) \n"
"\n"
"function printtable(node)\n"
"    -- to make output beautiful\n"
"    local function tab(amt)\n"
"        local str = \"\"\n"
"        for i=1,amt do\n"
"            str = str .. \"    \"\n"
"        end\n"
"        return str\n"
"    end\n"
"\n"
"    local cache, stack, output = {},{},{}\n"
"    local depth = 1\n"
"    local output_str = \"{\\n\"\n"
"\n"
"    while true do\n"
"        local size = 0\n"
"        for k,v in pairs(node) do\n"
"            size = size + 1\n"
"        end\n"
"\n"
"        local cur_index = 1\n"
"        for k,v in pairs(node) do\n"
"            if (cache[node] == nil) or (cur_index >= cache[node]) then\n"
"\n"
"                if (string.find(output_str,\"}\",output_str:len())) then\n"
"                    output_str = output_str .. \",\\n\"\n"
"                elseif not (string.find(output_str,\"\\n\",output_str:len())) then\n"
"                    output_str = output_str .. \"\\n\"\n"
"                end\n"
"\n"
"                -- This is necessary for working with HUGE tables otherwise we run out of memory using concat on huge strings\n"
"                table.insert(output,output_str)\n"
"                output_str = \"\"\n"
"\n"
"                local key\n"
"                if (type(k) == \"number\" or type(k) == \"boolean\") then\n"
"                    key = \"[\"..tostring(k)..\"]\"\n"
"                else\n"
"                    key = \"['\"..tostring(k)..\"']\"\n"
"                end\n"
"\n"
"                if (type(v) == \"number\" or type(v) == \"boolean\") then\n"
"                    output_str = output_str .. tab(depth) .. key .. \" = \"..tostring(v)\n"
"                elseif (type(v) == \"table\") then\n"
"                    output_str = output_str .. tab(depth) .. key .. \" = {\\n\"\n"
"                    table.insert(stack,node)\n"
"                    table.insert(stack,v)\n"
"                    cache[node] = cur_index+1\n"
"                    break\n"
"                else\n"
"                    output_str = output_str .. tab(depth) .. key .. \" = '\"..tostring(v)..\"'\"\n"
"                end\n"
"\n"
"                if (cur_index == size) then\n"
"                    output_str = output_str .. \"\\n\" .. tab(depth-1) .. \"}\"\n"
"                else\n"
"                    output_str = output_str .. \",\"\n"
"                end\n"
"            else\n"
"                -- close the table\n"
"                if (cur_index == size) then\n"
"                    output_str = output_str .. \"\\n\" .. tab(depth-1) .. \"}\"\n"
"                end\n"
"            end\n"
"\n"
"            cur_index = cur_index + 1\n"
"        end\n"
"\n"
"        if (size == 0) then\n"
"            output_str = output_str .. \"\\n\" .. tab(depth-1) .. \"}\"\n"
"        end\n"
"\n"
"        if (#stack > 0) then\n"
"            node = stack[#stack]\n"
"            stack[#stack] = nil\n"
"            depth = cache[node] == nil and depth + 1 or depth - 1\n"
"        else\n"
"            break\n"
"        end\n"
"    end\n"
"\n"
"    -- This is necessary for working with HUGE tables otherwise we run out of memory using concat on huge strings\n"
"    table.insert(output,output_str)\n"
"    output_str = table.concat(output)\n"
"\n"
"    print(output_str)\n"
"end";

bool luaopen_x64dbg_bootstrap(lua_State *L)
{
    luaL_loadstring(L, LuaBootstrap);
    int res = lua_pcall(L, 0, 0, 0);

    bool isError = (res != 0);

    if (isError)
    {
        const char *pszError = lua_tostring(L, -1);
        if (pszError)
        {
            _plugin_logprintf("Lua Bootstrap Error: %s\n", pszError);
        }
        return false;
    }

    return true;
}
